use std::env::Var;
use std::result::Result;

use http::server::HttpServer;
use http::server::Method;
use http::server::Request;
use http::server::Body;
use http::server::Suffix;

use md::Md;

use sqlx::Sqlx;
use sqlx::Pool;
use sqlx::Row;
use sqlx::Type;
use sqlx::Error;

mod slash;
mod counter;

use slash::Slash;
use counter::Counter;
use counter::Db;

struct DefaultHtml {
    head: string,
    body: string,
}

async fn main() -> Future<()> {
    let server = HttpServer::new();
    let sqlx = Sqlx::new();

    let port = 80;
    let host = "uberfoo.rs";

    let db = match Var::var("DATABASE_URL") {
        Result::Ok(db) => db,
        Result::Err(_) => "postgres://postgres:postgres@localhost/uberfoo.rs",
    };

    match sqlx.connect(db).await {
        Result::<Pool, Error>::Ok(pool) => {
            print("Connected to database\n");

            let default = "
            SELECT h.head, h.body
            FROM html h
            WHERE h.slug IS NULL;
            ";
            let map = pool.query(default);
            let html = map.map(|row: Row| -> DefaultHtml {
                let head = row.get("head", Type::String).unwrap();
                let body = row.get("body", Type::String).unwrap();
                DefaultHtml {
                    head: head,
                    body: body
                }
            });

            let html = html.fetch_one();
            let html: DefaultHtml = html.unwrap();

            server.route("/", Method::Get, Body::Text, |req: Request| -> string {
                Slash::emit(host, html.head, html.body)
            });

            server.prefix_route("/blog", Method::Get, Body::Text, |req: Request, prefix: Suffix| -> string {
                // This is a gnarly hack. If I don't do this then we can't reach
                // back far enough to find html from the next lambda. Clearly a ðŸª³.
                // To make it worse, I have to deconstruct the thing here, and
                // not down in the `if let` expressions down in the. No idea why.
                let default_body = html.body;
                let default_head = html.head;

                let query = "
                SELECT a.title, a.slug, a.published_at, m.markdown, h.head, h.body
                FROM article a
                JOIN markdown m ON a.content = m.id
                LEFT JOIN html h ON a.slug = h.slug
                WHERE a.slug = '${prefix.to_string()}';";

                let map = pool.query(query);
                let q = map.map(|row: Row| -> string {
                    let head:string = if let Result::Ok(head) = row.get("head", Type::String) {
                        head
                    } else {
                        default_head
                    };

                    let body:string = if let Result::Ok(body) = row.get("body", Type::String) {
                        body
                    } else {
                        default_body
                    };

                    let title = row.get("title", Type::String).unwrap();
                    let slug = row.get("slug", Type::String).unwrap();
                    let published_at = row.get("published_at", Type::Timestamp).unwrap();
                    let markdown = row.get("markdown", Type::String).unwrap();

                    let md = Md::new();
                    let html = md.to_html(markdown);

                    let html = "
<h1>${title}</h1>
<p>Published at ${published_at}</p>
${html}
";

                    let head = head.replace("TITLE", title);
                    let body = body.replace("MARKDOWN", html);

                    "
<!DOCTYPE html>
 <html lang='en'>
    <head>${head}</head>
    <body>
        ${body}
    </body>
</html>
                    "
                });

                match q.fetch_one() {
                    Result::<Row, Error>::Ok(article) => article as string,
                    Result::<Row, Error>::Err(e) => "Error loading article: ${e.to_string()}",
                }
            });

            server.route("/blog/counter", Method::Get, Body::Text, |req: Request| -> string {
                if let Result::<int, Error>::Ok(counter) = get_counter(pool) {
                    Counter::emit(host, counter, html.head, html.body)
                } else {
                    "Error loading counter"
                }
            });

            server.route("/blog/database", Method::Get, Body::Text, |req: Request| -> string {
                if let Result::<int, Error>::Ok(counter) = get_counter(pool) {
                    Db::emit(host, counter, html.head, html.body)
                } else {
                    "Error loading counter"
                }
            });

            server.route("/counter", Method::Get, Body::Text, |req: Request| -> string {
                if let Result::<int, Error>::Ok(counter) = get_counter(pool) {
                    counter as string
                } else {
                    "Error loading counter"
                }
            });

            server.route("/increment", Method::Post, Body::Text, |req: Request| -> string {
                if let Result::<int, Error>::Ok(counter) = get_counter(pool) {
                    counter = counter + 1;

                    let insert_query = "INSERT INTO counter (counter) VALUES ($1);";
                    let map = pool.query(insert_query);
                    let map = map.bind(counter);
                    map.execute();

                    counter as string
                } else {
                    "Error loading counter"
                }
            });

            server.route("/decrement", Method::Post, Body::Text, |req: Request| -> string {
                if let Result::<int, Error>::Ok(counter) = get_counter(pool) {
                    counter = counter - 1;

                    let insert_query = "INSERT INTO counter (counter) VALUES ($1);";
                    let map = pool.query(insert_query);
                    let map = map.bind(counter);
                    map.execute();

                    counter as string
                } else {
                    "Error loading counter"
                }
            });

            server.route("/counter_data", Method::Get, Body::Json, |req: Request| -> string {
                let select_query = "SELECT * FROM counter ORDER BY updated_at DESC LIMIT 50;";
                let map = pool.query(select_query);
                let q = map.map(|row: Row| -> string {
                    "{\"timestamp\": \"${row.get(\"updated_at\", Type::Timestamp).unwrap()}\", \"value\": ${row.get(\"counter\", Type::Short).unwrap()}}"
                });
                let data = q.fetch_all();

                let first = true;
                match data {
                    Result::<[Row], Error>::Ok(data) => {
                        let d = data as [string];

                        let data_string = "[";
                        for row in d {
                            if first {
                                first = false;
                                data_string = data_string + row;
                            } else {
                                data_string = data_string + ", " + row;
                            }
                        }
                        data_string + "]"
                    }
                    Result::<[string], Error>::Err(e) => "Error loading counter data",
                }
            });

            server.route("/help", Method::Get, Body::Text, |req: Request| -> string {
                "
                <p>hit the /counter endpoint to view the counter</p>
                <p>post to /increment to increment the counter</p>
                <p>post to /decrement to decrement the counter</p>
                "
            });

            server.use_tls("fullchain.pem", "privkey.pem");

            server.serve(port).await
        }
        Result::<Pool, Error>::Err(e) => {
            print("Error connecting to database: ${e.to_string()}\n");
        }
    }
}

fn get_counter(pool: Pool) -> Result<int, Error> {
    let select_query = "SELECT counter FROM counter ORDER BY updated_at DESC LIMIT 1;";
    let map = pool.query(select_query);
    let q = map.map(|row: Row| -> int {
        row.get("counter", Type::Short).unwrap()
    });
    match q.fetch_one() {
        Result::<Row, Error>::Ok(counter) => Result::<int, Error>::Ok(counter as int),
        Result::<Row, Error>::Err(e) => Result::<int, Error>::Err(e),
    }
}