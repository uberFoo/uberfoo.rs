DROP TABLE IF EXISTS article;
DROP TABLE IF EXISTS markdown;

-- This table stores the text for a page. That text is expected to be markdown.
CREATE TABLE markdown
(
    id SERIAL PRIMARY KEY,
    markdown TEXT
);

-- This is the main table for a blog post.
CREATE TABLE article
(
    slug VARCHAR(255) PRIMARY KEY,
    title VARCHAR(255),
    content INTEGER REFERENCES markdown(id),
    is_published BOOLEAN DEFAULT FALSE,
    published_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE OR REPLACE FUNCTION update_article(_slug VARCHAR(255), _is_published BOOLEAN)
RETURNS VOID AS $$
BEGIN
    UPDATE article
    SET is_published = _is_published,
        published_at = CASE WHEN _is_published THEN CURRENT_TIMESTAMP ELSE NULL END
    WHERE slug = _slug;
END;
$$ LANGUAGE plpgsql;

-- Insert posts
-- Insert the markdown
WITH markdown_insert AS (
    INSERT INTO markdown (markdown)
    VALUES ('
Happy Cinco de Mayo! 🎉💃

I have a lot to say about shared libraries, both with regards to [Rust](https://www.rust-lang.org) as well as [dwarf](https://github.com/uberFoo/dwarf).
What I plan on doing is discussing how to safely load shared libraries in Rust.
Then I''m going to talk about how dwarf leverages the former to extend the language.
If this sounds interesting to you, then read on!

## Shared Libraries in Rust

Loading a shared library in rust isn''t super difficult:

```rust
use libloading::{Library, Symbol};

fn main() {
    let lib = Library::new("path/to/your/library.so").unwrap();

    unsafe {
        let func: Symbol<unsafe extern fn()> = lib.get(b"function_name").unwrap();
        func();
    }
}
```

It is however unsafe.

Ensuring that types work across the FFI boundary is non-trivial because Rust doesn''t have a stable ABI.
Even changing compiler versions can break the process of loading a library at runtime.
To help deal with this situation there''s a crate called [abi_stable](https://docs.rs/abi_stable/latest/abi_stable/) to help.

I won''t try to describe what `abi_stable` does.
Instead I''ll quote from the documentation:

> [abi_stable is] For Rust-to-Rust ffi, with a focus on creating libraries loaded at program startup, and with load-time type-checking.
>
> This library allows defining Rust libraries that can be loaded at runtime, even if they were built with a different Rust version than the crate that depends on it.

When I was adding plugins to dwarf, my biggest challenge was figuring out how to use the `abi_stable` crate end-to-end.
Despite many examples available in the README I struggled to get a mental picture of what was needed.
Given the effort and time it took, it makes sense to me to document the process here.

To be clear, the goal is to load a shared library that contains functions that we''d like to call.
For dwarf, they enable some functionality external to the dwarf binary.

To summarize the process, we''ll be using the `abi_stable` crate; sometimes it shows up as `sabi`.
To use the crate we''ll need to define a trait that contains the functions we want to call in the shared library.
Next we define a struct that ultimately serves as the plugin "container" that surfaces a function (`new`) to construct a plugin.
After that you will need to create your plugin implementation, according to the work done above.
And finally, you can load and use the shared library from your main code.

Below is a diagram showing all the moving parts.

```mermaid
graph TD
        G["Rust Code (dwarf)"] -- calls --> B
        A["Trait (API)"] -- generated --> B(["PluginType (Trait Object)"])
        B --> C[PluginModule]
        C -- generated --> D([PluginModRef])
        D --> E[RootModule]
        D -- loader --> F[Plugin Implementation]
        F -- returns --> B
```

The square boxes in the diagram correspond to the code that we''ll be writing.
The rounded boxes are the parts that are generated by the `abi_stable` crate.
This will all be made clear in the following sections.

### Plugin API (Trait)

The code in this section comes from [plug_in.rs](https://github.com/uberFoo/dwarf/blob/develop/src/plug_in.rs) in the dwarf source tree.

The first thing that we want to do is determine the API that we''d like to have.
For dwarf we want to be able to call static methods to create new instances, and invoke arbitrary methods on them.
For example,

```rust
use sqlx::Sqlx;

fn main() {
    let s = Sqlx::new()
    s.connect(...);
}
```

To achieve this sort of generality we need to pass along all of the information needed to invoke a method.
We can do this by simply passing in the constituent parts of the method call.

In the first line of the above example we can see that the type is "Sqlx", and the method name is "new".
In the second line, we know the type from the previous line, and the method name is "connect".
In both cases, the module is "sqlx".
We''ve essentially factored out what we need to make this work.


The results are below in the function `invoke_func`.
`invoke_func` simply takes the `module`, `ty`, and `name` as `RStr`s, in addition to the function arguments.
`invoke_func` is a `fn` on a trait that we expose to `abi_stable` using the `#[sabi_trait]` attribute.
This is how we define our API.

```rust
#[sabi_trait]
pub trait Plugin: Clone + Debug + Display + Send + Sync {
    /// Invoke a function in the plugin.
    ///
    /// # Parameters
    /// - `module`: The module in which the function is defined.
    /// - `ty`: The type of the function.
    /// - `name`: The name of the function.
    /// - `args`: The arguments to the function.
    ///
    /// Invoke a function in the plugin, using the `module`, `ty`, and `name` to
    /// locate the function, and `args` as the arguments to the function.
    fn invoke_func(
        &self,
        module: RStr<''_>,
        ty: RStr<''_>,
        name: RStr<''_>,
        args: RVec<FfiValue>,
    ) -> RResult<FfiValue, Error>;

    /// Invoke a mutable function in the plugin.
    ///
    /// # Parameters
    /// - `module`: The module in which the function is defined.
    /// - `ty`: The type of the function.
    /// - `name`: The name of the function.
    /// - `args`: The arguments to the function.
    ///
    /// Invoke a mutable function in the plugin, using the `module`, `ty`, and `name` to
    /// locate the function, and `args` as the arguments to the function.
    ///
    /// This is the same as `invoke_func` but with a mutable reference to self.
    fn invoke_func_mut(
        &mut self,
        module: RStr<''_>,
        ty: RStr<''_>,
        name: RStr<''_>,
        args: RVec<FfiValue>,
    ) -> RResult<FfiValue, Error>;

    #[sabi(last_prefix_field)]
    /// Return the name
    ///
    /// The name of this plugin.
    fn name(&self) -> RStr<''_>;
}

pub type PluginType = Plugin_TO<''static, RBox<()>>;
```

Now what''s this `RStr` type?

Well, we are limited in what we send across the FFI boundary using `sabi`.
`abi_stable` has FFI-friendly analogs of most of the Rust types, as well as a few others.
`RStr` is the FFI-friendly `&str` analog.
There are also `RResult`, `ROk`, `RString`, etc.
Additionally there are types from the [crossbeam](https://docs.rs/crossbeam/latest/crossbeam/) crate to support channels.
We use channels to send dwarf lambda calls across the FFI boundary, although I think I''ll save that for a different article.

Note the `FfiValue` type that is returned by `invoke_func`, as well as accepted as input arguments.
This is an FFI-safe version of dwarf''s value type.
We use `FfiValue`s to pass values back and forth between the plugin.
The [source](#ffivalue) is below if you''d like to see it.

Now back to our `Plugin` trait.
In addition to `invoke_func` there is `invoke_func_mut`, for when you really need to mutate `self`.
Note that this comes with a price: a mutex gets locked and any attempt at re-entrance will deadlock.
I am on the fence about this function.
On one hand, we can get by without it by using internal mutability.
On the other hand,  sometimes I really wish there were a mutable self available in some other crates.

Finally is the `name` method, which returns the name of the plugin.
Note the attribute above `name`.
This get''s shuffled around after you''ve released a version, and later add fields.
I **have not** used this, and I''m not really familiar with how it works.

Also note the `PluginType` type.
It is an alias for the trait object that is generated by the `#[sabi_trait]` attribute.
It is used below, in the `PluginModule` type.

### PluginModule

The code in this section comes from [plug_in.rs](https://github.com/uberFoo/dwarf/blob/develop/src/plug_in.rs) in the dwarf source tree.

The struct `PluginModule` is the means we are given to instantiate a plugin.
It contains pointers to functions that will be provided by every plugin.
In dwarf this means that the all of the plugins, (e.g., `http` `sqlx`, etc.), have the same functions.
This allows us to load any plugin and call the same functions on it.

In order to be useful, one of those functions needs to return a `PluginType` trait object, and that method is generally called `new`.
Remember that the `PluginType` is the trait object that is generated from the trait that we defined above.

Note that our `new` function takes an `RSender<LambdaCall>` and an `RVec<FfiValue>`.
The former is how we can invoke lambdas from the plugin, and I''ll write about that separately.
The latter are for passing arguments to the `new` function implementation in the plugin.
And as required, we return a `PluginType` via an `RResult<PluginType, Error>`.

```rust
#[repr(C)]
#[derive(StableAbi)]
#[sabi(kind(Prefix(prefix_ref = PluginModRef)))]
#[sabi(missing_field(panic))]
pub struct PluginModule {
    pub name: extern "C" fn() -> RStr<''static>,
    #[sabi(last_prefix_field)]
    pub new: extern "C" fn(RSender<LambdaCall>, RVec<FfiValue>) -> RResult<PluginType, Error>,
}

impl RootModule for PluginModRef {
    declare_root_module_statics! {PluginModRef}
    const BASE_NAME: &''static str = "plugin";
    const NAME: &''static str = "plugin";
    const VERSION_STRINGS: VersionStrings = package_version_strings!();
}
```

I don''t have a lot of insight into `RootModule` impl.
I just set it up with some generic strings and left it like I found it in the example code.
It''s clearly some defaults and some glue (`declare_root_module_statics!`) -- I''ve never had to mess with it.
It is however necessary for the `export_root_module` attribute to work, below.

### Plugin Loader

The code in this section comes from [vm.rs](https://github.com/uberFoo/dwarf/blob/develop/src/bubba/vm.rs) in the dwarf source tree.
This code comes from the virtual machine and is how a plugin is loaded.
Once a plugin is loaded we can call the `invoke_func` method on it.

It''s not difficult loading a plugin into memory.
The first step is calling `RawLibrary::path_in_directory` with a path to the plugin.
The function also takes the name of the file and the file''s suffix.
Using `LibrarySuffix::NoSuffix` is good for cross platform work, as sabi figures out the extension for you.
`RawLibrary::path_in_directory` returns a `PathBuf` to the shared library file.

```rust
let library_path = RawLibrary::path_in_directory(
    Path::new(&format!(
        "{}/extensions/{}/lib",
        self.home.display(),
        plugin_root,
    )),
    plugin_root.as_str(),
    LibrarySuffix::NoSuffix,
);
```

Next up we use the library path to initialize the root module and get a handle to our `PluginModRef`.
Like so:

```rust
let root_module = (|| {
    let header = lib_header_from_path(&library_path)?;
    header.init_root_module::<PluginModRef>()
})()
```

There is some error handling elided from the example, which is why it may look odd.

Finally we can get a pointer to our plugin''s `new` function ([see here](#pluginmodule)) in the `ctor` variable.
Invoking `ctor` (`new`) finally gives us an instance of our PluginType trait object
```rust
let ctor = root_module.new();
let plugin = ctor(self.lambda_sender.clone().into(), args.into()).unwrap();
```

### Plugin Implementation

The code in this section comes from [plugins/sqlx/src/lib.rs](https://github.com/uberFoo/dwarf/blob/develop/plugins/sqlx/src/lib.rs) in the dwarf source tree.

That was the setup.
Now we take a look at the implementation side of the plugin.
For this example we''ll be creating a plugin that connects to a Postgres database.
To connect to Postgres we will use the [sqlx](https://github.com/launchbadge/sqlx) crate.

This first snippet is really the magic that makes the whole thing work.
By implementing `RootModule` above, we are able to apply the `#[export_root_module]` attribute to the `instantiate_root_module` function.
The function returns a `PluginModRef`, which is some generated magic that allows us to return an instance of our plugin.
Specifically we return a `PluginModule` struct that contains the functions that we defined above.

```rust
#[export_root_module]
pub fn instantiate_root_module() -> PluginModRef {
    PluginModule { name, new }.leak_into_prefix()
}
```

The following bit''s of code illustrate the functions returned by `instantiate_root_module`.
It includes the `name` function, as well as the `new` function.
While `name` is pretty self explanatory, `new` is a bit interesting.
It creates a new instance of the plugin, and returns a `PluginType` trait object.

```rust
#[sabi_extern_fn]
pub fn name() -> RStr<''static> {
    "sqlx".into()
}

/// Instantiates the plugin.
#[sabi_extern_fn]
pub fn new(
    lambda_sender: RSender<LambdaCall>,
    _args: RVec<FfiValue>,
) -> RResult<PluginType, Error> {
    ROk(Plugin_TO::from_value(Sqlx::new(lambda_sender), TD_Opaque))
}
```

The plugin implementation is hanging of off the `Sqlx` struct.
The struct itself contains [`Slab`](https://github.com/tokio-rs/slab)s to store data across calls.
For example, some of the functions return errors.
We can''t actually send an error type across the FFI boundary because we only deal is `FfiValue`s, so we store them in a `Slab` and return a handle to the error.
We surface insight into the error by having an `Error::to_string` method that returns the error message.

```rust
struct Sqlx {
    lambda_call: RSender<LambdaCall>,
    pools: Arc<Mutex<Slab<sqlx::Pool<Postgres>>>>,
    errors: Arc<Mutex<Slab<Arc<SqlxError>>>>,
    rows: Arc<Mutex<Slab<Arc<sqlx::postgres::PgRow>>>>,
}
```
All that''s left to do is to implement the functions that we defined in the API.
Below I get into that implementation, and how it works with the dwarf source code
along side it to provide a nice API to the user.

> That''s about all you need to build a plugin system in Rust.
> Below I delve a bit more deeply into the implementation of the API for an SQL plugin for dwarf.
> This isn''t strictly necessary for getting a dynamic plugin system up and running, but it''s a good example of how to use the API.

Below is a bit of the API implementation.
The first thing to notice is that the `invoke_func` function is not async, but it calls an async function.
We wrap it in `future::block_on` to make it work.

The example is for the `Query::query_all` function, which is used to run a query and return the results.
The code is fairly simple and self-explanatory.

```rust
impl Plugin for Sqlx {
     fn invoke_func(
         &self,
         module: RStr<''_>,
         ty: RStr<''_>,
         func: RStr<''_>,
         args: RVec<FfiValue>,
     ) -> RResult<FfiValue, Error> {
         future::block_on(async {
             match ty.as_str() {
                    "Sqlx" => match func.as_str() {
                        // This handles the connect call.
                        "connect" => {...}
                    }
                    "Error" => match func.as_str() {
                        // For a given error handle, return the error message.
                        "to_string" => {...}
                    }
                    "Map" => match func.as_str() {
                        // This is generally used for posting a query.
                        "execute" => {...}
                    }
                    "Row" => match func.as_str() {
                        // Given a row handle, return the value for a given key.
                        "get" => {...}
                    }
                    "Query" => match func.as_str() {
                        "query_one" => {...}
                        "query_all" => {
                            // The first parameter is the query string.
                            let query: String = args
                                .first()
                                .unwrap()
                                .try_into()
                                .map_err(|e: ChaChaError| Error::Plugin(e.to_string().into()))
                                .unwrap();

                            // The second parameter is a handle to the pool.
                            let pool: DwarfInteger = args
                                .get(1)
                                .unwrap()
                                .try_into()
                                .map_err(|e: ChaChaError| Error::Plugin(e.to_string().into()))
                                .unwrap();

                            // The lambda to invoke on the result.
                            let FfiValue::Lambda(lambda) = args.get(2).unwrap() else {
                                panic!("Invalid lambda");
                            };

                            let bindings: Vec<FfiValue> = args
                                .get(3)
                                .unwrap()
                                .clone()
                                .try_into()
                                .map_err(|e: ChaChaError| Error::Plugin(e.to_string().into()))
                                .unwrap();

                            // Dereference the pool handle
                            let guard = self.pools.lock().unwrap();
                            let pool = guard.get(pool as usize).unwrap();

                            // Build the query
                            let mut result = sqlx::query(&query);

                            // Add bindings to the query
                            for binding in bindings {
                                match binding {
                                    FfiValue::String(value) => {
                                        result = result.bind(value.to_string());
                                    }
                                    FfiValue::Integer(value) => {
                                        result = result.bind(value as i64);
                                    }
                                    _ => {
                                        panic!("Invalid binding");
                                    }
                                }
                            }

                            // Run the query, mapping results to the lambda.
                            let result = result
                                .map(|row: sqlx::postgres::PgRow| {
                                    // This is how we get the result of running the lambda.
                                    let (s, result) = crossbeam::channel::bounded(1);

                                    // Store the result locally. We can''t return the row directly --
                                    // we can only return `FfiValue`''s.
                                    let key = {
                                        let mut guard = self.rows.lock().unwrap();
                                        guard.insert(Arc::new(row))
                                    };

                                    // Invoke the lambda, passing a handle to the row.
                                    let lambda_call = LambdaCall {
                                        lambda: *lambda,
                                        args: vec![FfiValue::Integer(key as DwarfInteger)].into(),
                                        result: s.into(),
                                    };
                                    self.lambda_call.send(lambda_call).unwrap();

                                    // Wait for the result.
                                    let result = result.recv().unwrap();

                                    // Remove the row.
                                    let mut guard = self.rows.lock().unwrap();
                                    guard.remove(key);

                                    // Return the result from the lambda.
                                    result.unwrap()
                                })
                                .fetch_all(pool)
                                .await;

                            // Now we wrap the result up as an RResult that may be sent back
                            // to dwarf.
                            let result = match result {
                                Ok(result) => ROk(RBox::new(result.into())),
                                Err(e) => {
                                    let mut guard = self.errors.lock().unwrap();
                                    let entry = guard.vacant_entry();
                                    let key = entry.key();
                                    guard.insert(Arc::new(e));
                                    RErr(RBox::new(FfiValue::Integer(key as DwarfInteger)))
                                }
                            };
                            Ok(FfiValue::Result(result))
                        }
                        func => Err(Error::Plugin(format!("Invalid function: {func}").into())),
                    },
                    ty => Err(Error::Plugin(format!("Invalid type: {ty}").into())),
                }
                .into()
            })
        }
    }
}
```
There are a few things to note.
The first is that we are running a lambda inside of the Query::map.
This allows for the following in dwarf:

```rust
let map = pool.query(default);
let html = map.map(|row: Row| -> DefaultHtml {
    let head = row.get("head", Type::String).unwrap();
    let body = row.get("body", Type::String).unwrap();
    DefaultHtml {
        head: head,
        body: body
    }
});
```

The second thing to note is that although the lambda in the dwarf code above is expecting a `Row`, the plugin can only send `FfiValue`s.
To work around this, we store the `Row` in a `Slab` and send a handle to the `Row` across the FFI boundary.
The dwarf code in the plugin makes it look like we are getting a `Row` back via pure trickery:

```rust
/// Map over the results of the query.
///
/// Note that we don''t actually do any work here. We are just setting everything
/// up to be done by [`Query`]s `fetch_all` or `fetch_one` calls.
fn map<T>(self, func: fn(Row) -> T) -> Query<T> {
    // This is fun. We need to bounce the function to the Query struct because
    // we need to execute the user `func` on a `Row` struct, not an `int`.
    // So we wrap the result of the function in a `Row` struct and pass that
    // to the closure.
    let bounce = |row: int| -> T {
        let row = Row {
            plugin: self.plugin,
            inner: row,
        };
        func(row)
    };
    // Finally down here we create the Query struct (with our neat-o bounce
    // function) and return it.
    Query {
        plugin: self.plugin,
        query: self.query,
        func: bounce,
        pool: self.pool,
        bindings: self.bindings,
    }
}
```

Note that above we are replacing the lambda with a closure that takes an integer and constructs a `Row` from it.

## Plugins in dwarf

The code in this section comes from [plugins/sqlx/ore/lib.ore](https://github.com/uberFoo/dwarf/blob/develop/plugins/sqlx/ore/lib.ore) in the dwarf source tree.

Plugins are the primary method for adding functionality to the language -- as libraries.
To load a plugin in dwarf, you just use it: `use sqlx::Sqlx;`.
This starts a cascade of actions that begins with parsing, and ultimately ends with the plugin being loaded into memory.

This dwarf code will serve as an example of how to use the plugin system.
We will use this to motivate the discussion.

```rust
use sqlx::Sqlx;

struct DefaultHtml {
    head: string,
    body: string,
}

// Connect to the database
 match sqlx.connect("postgres:://postgres:postgres@localhost/uberfoo.rs").await {
    Result::<Pool, Error>::Ok(pool) => {
        // Build query
        let default = "
        SELECT h.head, h.body
        FROM html h
        WHERE h.slug IS NULL;
        ";
        // This is the pool from above.
        let map = pool.query(default);

        // This is the code that will run for each row of the result.
        let html = map.map(|row: Row| -> DefaultHtml {
            // This is our lambda where we can actually do stuff with the rows.
            let head = row.get("head", Type::String).unwrap();
            let body = row.get("body", Type::String).unwrap();
            DefaultHtml {
                head: head,
                body: body
            }
        });

        // Run the query
        let html = html.fetch_one();
        let html: DefaultHtml = html.unwrap();
    }
    Result::<Pool, Error>::Err(e) => {
        // Oops
        print("Error connecting to database: ${e.to_string()}\n");
    }
}
```

We are simply connecting to the database and running a query.
We create the query using `pool.query` passing the query string.
We are selecting the default head and body of the site.
The results of the query is a map over the results.
We use a lambda to map over the results.
The lambda is called for each returned row.
Inside the lambda we extract and store the returned rows in the `DefaultHtml` struct.
`fetch_one` is what kicks off the query.

Below is a bit of the `Sqlx` dwarf plugin.

```rust
/// The main entry point for the SQLx plugin.
///
/// This struct is the main entry point for the SQLx plugin. It is responsible for
/// creating connections to the database.
struct Sqlx {
    /// The plugin that is responsible for all communication with the database.
    #[proxy(plugin = "sqlx")]
    plugin: Plugin<Sqlx>,
}

impl Sqlx {
    /// Create a new instance of the SQLx plugin.
    ///
    /// This function creates a new instance of the SQLx plugin. It is the main entry
    /// point for the plugin and is responsible for creating connections to the database.
    ///
    /// ```
    /// # use sqlx::Sqlx;
    /// let sqlx = Sqlx::new();
    /// ```
    fn new() -> Self {
        Sqlx {
            plugin: Plugin::<Sqlx>::new(),
        }
    }

    /// Connect to the Database
    ///
    /// # Parameters
    ///
    /// - `connection_string`: The connection string to the database
    ///
    /// The value returned in `pool` is an int that represents the connection pool.
    /// We create a new `Pool` struct with this value and return it to the user;
    /// or an error if that should occur. As with `Pool`, the error needs to be
    /// wrapped in an `Error` struct.
    ///
    /// ```
    /// # use sqlx::Sqlx;
    /// # use std::result::Result;
    /// # async fn example() {
    /// let sqlx = Sqlx::new();
    /// let pool = sqlx.connect("postgres://user:pass@localhost:5432/db");
    /// # }
    /// ```
    async fn connect(self, connection_string: string) -> Future<Result<Pool, Error>> {
        let pool = self
            .plugin
            .invoke_func_mut("sqlx", "Sqlx", "connect", [connection_string]);

        match pool {
            Result::Ok(p) => Result::<Pool, Error>::Ok(Pool {
                plugin: self.plugin,
                inner: p,
            }),
            Result::Err(e) => {
                Result::<Pool, Error>::Err(Error {
                plugin: self.plugin,
                inner: e,
            })}
        }
    }
}
```

The first thing to notice is the `#[proxy(plugin = "sqlx")]` attribute above the `plugin` field in the `Sqlx` struct.
That bit of code is our window into the plugin.
It marks `plugin` as a proxy for the `sqlx` plugin.
In the impl for `connect` you can see it being used with the `invoke_func_mut` call discussed above.
But that''s jumping ahead.

 the `new` method.
It''s here that the plugin is actually instantiated with the call to `Plugin::<Sqlx>::new`.
The compiler has a special case built into static method calls that keys off `Plugin`.
The virtual machine has an instruction that is especially for loading the plugin.
It''s here that we call the code in the [loader section](#plugin-loader).

Getting back to `connect`.
First off notice that we are calling our `invoke_func_mut` function in the plugin.
The result type is `Result<int, int>`, and that''s not very helpful.
We need to wrap it in a `Pool` struct, which is what we return to the user.
If there is an error, we wrap that in an `Error` struct and return that instead.

The Pool struct in the plugin is pretty simple.
It surfaces one method, `query`, which is used to run a query.
Note that in the plugin all we are actually doing is storing the query string in a `Map` object.
We also store a handle to the plugin and the pool.

```rust
/// A connection pool to the database.
struct Pool {
    /// The plugin that is responsible for all communication with the database.
    #[proxy(plugin = "sqlx")]
    plugin: Plugin<Sqlx>,
    /// A handle to the connection pool in the plugin.
    inner: int,
}

impl Pool {
    /// Execute a query.
    ///
    /// # Parameters
    /// - `query`: The query to execute
    ///
    /// The result returned is a `Map` struct that represents the future query.
    /// Note that this is all just dwarf code; nothing is being done with the
    /// plugin just yet.
    ///
    /// ```
    /// # use sqlx::Sqlx;
    /// # use std::result::Result;
    /// # async fn example() {
    /// let sqlx = Sqlx::new();
    /// let pool = sqlx.connect("postgres://user:pass@localhost:5432/db").await.unwrap();
    /// let map = pool.query("SELECT * FROM users");
    /// # }
    /// ```
    fn query<F>(self, query: string) -> Map {
        Map{
            plugin: self.plugin,
            query: query,
            pool: self.inner,
            bindings: [],
        }
    }
}
```

The `Map` struct provides a method to map over the results of a query.
It''s a bit more complex than the `Pool` struct.
The `Map` struct is responsible for storing the query string, the connection pool, and the bindings for the query.

```rust
/// A map of a query.
///
/// This struct represents a map of a query. It is responsible for storing the query
/// string, the connection pool, and the bindings for the query. It is also responsible
/// for executing the query. Finally, it provides a method for mapping over the
/// results of the query.
struct Map {
    /// The plugin that is responsible for all communication with the database.
    #[proxy(plugin = "sqlx")]
    plugin: Plugin<Sqlx>,
    /// The query string.
    query: string,
    /// A handle to the connection pool in the plugin.
    pool: int,
    /// The bindings for the query.
    ///
    /// This should be a heterogenous list -- it works as is though, which is scary.
    /// It''s not a heterogenous list because dwarf doesn''t support that as a type yet.
    bindings: [string],
}

impl Map {
    /// Map over the results of the query.
    ///
    /// Note that we don''t actually do any work here. We are just setting everything
    /// up to be done by [`Query`]s `fetch_all` or `fetch_one` calls.
    ///
    /// # Parameters
    ///
    /// - `func`: The function to execute on each row
    ///
    /// ```
    /// # use sqlx::Sqlx;
    /// # use std::result::Result;
    /// # async fn example() {
    /// let sqlx = Sqlx::new();
    /// let pool = sqlx.connect("postgres://user:pass@localhost:5432/db").await.unwrap();
    /// let query = pool.query("SELECT * FROM users");
    /// let map = map.map(|row| -> int {
    ///    let id: int = row.get("id", Type::Integer).unwrap();
    ///    id
    /// }
    /// # }
    /// ```
    fn map<T>(self, func: fn(Row) -> T) -> Query<T> {
        // This is fun. We need to bounce the function to the Query struct because
        // we need to execute the user `func` on a `Row` struct, not an `int`.
        // So we wrap the result of the function in a `Row` struct and pass that
        // to the closure.
        let bounce = |row: int| -> T {
            let row = Row {
                plugin: self.plugin,
                inner: row,
            };
            func(row)
        };

        // Finally down here we create the Query struct (with our neat-o bounce
        // function) and return it.
        Query {
            plugin: self.plugin,
            query: self.query,
            func: bounce,
            pool: self.pool,
            bindings: self.bindings,
        }
    }
}
```

The example code only shows the `map` function.
`map` is used to map over the results of a query.
It takes a lambda that is called for each row of the query.
The lambda is passed a `Row` struct, which is a handle to the row in the plugin.
The row struct is again not returned from the plugin since we can only deal with `FfiValue` types, so we return an int handle.
In the code above we wrap that in a `Row` struct and pass it to the lambda.

Not that we still haven''t actually run the query.
Instead we return yet another object called `Query`, which is discussed below.

Our `Query` struct is responsible for fetching the results of the query.
Below we show the `fetch_one` function, which fetches one row from the query.
There is also a `fetch_all` function that fetches all the rows from the query.

```rust
struct Query<T> {
    /// The plugin that is responsible for all communication with the database.
    #[proxy(plugin = "sqlx")]
    plugin: Plugin<Sqlx>,
    query: string,
    func: T,
    // I feel like this would be more accurate, but it causes the extruder to panic.
    // func: fn(Row) -> T,
    pool: int,
    /// The bindings for the query.
    ///
    /// This should be a heterogenous list -- it works as is though, which is scary.
    /// It''s not a heterogenous list because dwarf doesn''t support that as a type yet.
    bindings: [string],
}

impl Query<T> {
    /// Fetch one row from the query.
    ///
    /// # Parameters
    ///
    /// None
    ///
    /// Our `self` is the `Query` struct instantiated by the Map implementation. Our
    /// job is to return ane row from the query. Note that it is best that your query
    /// return only one row.
    ///
    /// The result is a row that may be deconstructed for it''s columnar data.
    ///
    /// ```
    /// # use sqlx::Sqlx;
    /// # use std::result::Result;
    /// # async fn example() {
    /// let sqlx = Sqlx::new();
    /// let pool = sqlx.connect("postgres://user:pass@localhost:5432/db").await.unwrap();
    /// let query = pool.query("SELECT * FROM users");
    /// let map = map.map(|row| -> int {
    ///    let id: int = row.get("id", Type::Integer).unwrap();
    ///    id
    /// }
    /// let id = map.fetch_one();
    /// # }
    /// ```
    fn fetch_one(self) -> Result<Row, Error> {
        let row = self
            .plugin
            .invoke_func("sqlx", "Query", "query_one", @[self.query, self.pool, self.func, self.bindings]);

        match row {
            Result::Ok(row) => Result::<Row, Error>::Ok(row),
            Result::Err(e) => {
                let e = Error {
                    plugin: self.plugin,
                    inner: e,
                };
                Result::<Row, Error>::Err(e)
            }
        }
    }
}
```

`fetch_one` is pretty straightforward.
It calls the `invoke_func` function in the plugin, passing the query string, the pool, the lambda, and the bindings.
The result is a `Row` struct that represents the row returned from the query.
Again, we transform the result.
In this case from `Result<int, int>` to `Result<Row, Error>`.

Finally, we get to the `Row` type.
Row has one method: `get`.
`get` is used to get a value from a row.
The result is according to the generic type `T`.


```rust
/// A row returned from a query.
///
/// This struct represents a row returned from a query. It is responsible for
/// storing a reference to the plugin that created it, as well as the row itself.
/// Since the row is a handle to a row in the plugin, it is an int.
struct Row {
    /// The plugin that is responsible for all communication with the database.
    #[proxy(plugin = "sqlx")]
    plugin: Plugin<Sqlx>,
    inner: int,
}

impl Row {
    /// Get a value from a row.
    ///
    /// # Parameters
    ///
    /// - `index`: The index of the value to get -- note that this is a string
    /// - `ty`: The [`Type`] of the value to get
    ///
    /// The result returned is according to the generic type `T`.
    fn get<T>(self, index: string, ty: Type) -> Result<T, Error> {
        let row = self.plugin.invoke_func("sqlx", "Row", "get", @[self.inner, index, ty]);

        match row {
            Result::Ok(row) => Result::<T, Error>::Ok(row),
            Result::Err(e) => {
                let e = Error {
                    plugin: self.plugin,
                    inner: e,
                };
                Result::<T, Error>::Err(e)
            }
        }
    }
}
```

## Conclusion

Putting together a plugin system in Rust is sort of convoluted.
Keeping all the various traits and types in your head is a bit of a challenge.
Hopefully this article has helped to clarify the process.

Actually adding plugin functionality to a programming language is a bit more involved.
I''ve touched on the important bits, but there are a lot of details that I''ve left out.
For example, I didn''t talk about how the lambda functions work across the FFI boundary.

I hope that this article has been helpful, and I''m happy to answer questions -- just reach out.
If you like what I''m doing with dwarf, please consider leaving a star on the [dwarf GitHub repo](https://www.github.com/uberFoo/dwarf).

## Ffivalue
```rust
#[repr(C)]
#[derive(Clone, Debug, Default, StableAbi)]
pub enum FfiValue {
    /// Boolean
    ///
    /// A boolean value.
    Boolean(bool),
    /// Empty
    ///
    /// This is equivalent to `()`.
    #[default]
    Empty,
    /// Error
    ///
    /// An error message.
    Error(RString),
    /// Float
    ///
    /// A floating point number.
    Float(DwarfFloat),
    /// Integer
    ///
    /// An integer number.
    Integer(DwarfInteger),
    /// Lambda
    ///
    /// A handle to a lambda function. This is used to invoke a lambda function
    /// from dwarf in the plugin.
    Lambda(usize),
    /// List
    ///
    /// A list of values; aka a Vec.
    List(RVec<Self>),
    /// Option
    ///
    /// An optional value. Note that this is not the same as `Option<T>`, but
    /// uses the FFI-safe `ROption` type.
    Option(ROption<RBox<Self>>),
    /// PlugIn
    ///
    /// A plugin type.
    PlugIn(PluginType),
    /// Range
    ///
    /// A range of integers, with a start and an end.
    Range(FfiRange),
    /// Result
    ///
    /// A result type. Note that this is not the same as `Result<T, E>`, but
    /// uses the FFI-safe `RResult` type.
    Result(RResult<RBox<Self>, RBox<Self>>),
    /// String
    ///
    /// A string. Note that this is not the same as `String`, but uses the
    /// FFI-safe `RString` type.
    String(RString),
    /// Struct
    ///
    /// This is a user defined struct.
    Struct(FfiStruct),
    /// A value of unknown type.
    ///
    /// This is useful for dumping value that maybe we just don''t want to deal
    /// with, or that we don''t know how to deal with. It''s probably a terrible
    /// crutch that will come back and bite me.
    Unknown,
    /// UUID type
    ///
    /// Version 4 UUID.
    Uuid(FfiUuid),
}
```
')
    RETURNING id
)
    -- Insert the article
INSERT INTO article (title, slug, content, published_at)
VALUES ('Plugins in Rust', 'plugins', (SELECT id FROM markdown_insert), TIMESTAMP '2024-05-05 00:04:20');

-- This is a table to hold the html that comes before and after the markdown
-- from the article.
CREATE TABLE html
(
    slug VARCHAR(255),
    head TEXT,
    body TEXT,
    FOREIGN KEY (slug) REFERENCES article(slug) ON DELETE CASCADE
);

INSERT INTO html (slug, head, body)
VALUES(NULL,
-- This is the head of the HTML
'
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-RZXB2EDQ6F"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag("js", new Date());

      gtag("config", "G-RZXB2EDQ6F");
    </script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" type="image/png" href="/favicon.png">
    <title>TITLE</title>
    <style>
        @import url("https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/tomorrow-night-bright.css");
        @import url("https://fonts.googleapis.com/css2?family=JetBrains+Mono&display=swap");

        @font-face {
            font-family: "3270";
            src: url("/3270Condensed-Regular.woff") format("woff");
            font-weight: normal;
            font-style: normal;
        }

        body {
            background-image: url("/hacking.webp");
            background-size: cover;
            background-repeat: no-repeat;
            background-position: center;
            background-attachment: fixed;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #fff;
            /* White text color */
            font-family: "JetBrains Mono", monospace;
            /* Monospaced, old school feel */
        }

        body::before {
            content: "";
            position: fixed;
            top: 0;
            right: 0;
            bottom: 0;
            left: 0;
            background-image: url("/hacking.webp");
            background-size: cover;
            background-repeat: no-repeat;
            background-position: center;
            z-index: -1;
        }

        /* Main Content Styles */
        .body-container {
            text-align: left;
            margin-top: 60px; /* Adjust based on nav height */
            padding: 20px;
            background-color: rgba(0, 0, 0, 0.8);
            border-radius: 10px;
            width: 90%;
            max-width: 800px;
            min-height: 100vh;
        }

        .body-container blockquote {
            margin: 20px;
            padding: 20px;
            background-color: #333; /* Dark background, resembling a terminal */
            border-left: 10px solid #0c7b93; /* A bright teal accent line */
            color: #8ec07c; /* Light green color typical of old monochrome monitors */
            font-family: ''Courier New'', Courier, monospace; /* Monospaced font for the code-like appearance */
            text-shadow: 0 0 3px #000; /* Text shadow for a slight glowing effect */
            box-shadow: 0 2px 5px rgba(0,0,0,0.2); /* Subtle shadow for depth */
            border-radius: 4px; /* Soften the edges */
        }

        .body-container blockquote p {
            margin: 0; /* Remove default margin */
            font-family: "3270", monospace;
            font-size: 1.5em; /* Slightly larger font size for emphasis */
        }

        .body-container code {
            border-radius: 10px;
            color: #9edc8f;
            font-size: 1.2em;
            font-family: "3270", monospace;
        }

        .body-container h1, .body-container h2, .body-container h3, .body-container h4, .body-container h5, .body-container h6 {
            color: green;
            /* text-shadow: 2px 2px 4px rgba(55, 155, 55, 0.5); */
        }

        .body-container h1 {
            font-size: 2em;
        }

        .body-container p {
            font-size: 1em;
        }

        .body-container a {
            display: inline-block;
            margin-top: 5px;
            padding: 0px 5px;
            background-color: #0c7b93;
            color: white;
            text-decoration: none;
            border-radius: 5px;
        }

        .body-container a:hover {
            background-color: #0a5968;
        }

        .body-container canvas {
            background-color: #000000;
        }

        /* Navigation Styles */
        .nav-container {
            background-color: rgba(0, 0, 0, 0.8);
            text-align: center;
            width: 100%;
            position: fixed;
            top: 0;
            left: 0;
            z-index: 1000;
            overflow: hidden;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        nav ul {
            list-style: none;
            padding: 0;
            margin: 0;
            width: 100%;
            display: block;
            text-align: center;
        }

        nav ul li {
            position: relative;
            display: inline-block;
        }

        nav ul li a {
            text-decoration: none;
            padding: 10px 20px;
            color: white;
            display: block;
        }

        nav ul li ul {
            display: none;
            position: absolute;
            background-color: #444;
            top: 100%;
            left: 0;
            width: 100%;
            z-index: 1001;
        }

        nav ul li:hover ul {
            display: block;
        }

        .menu-toggle {
            display: none;
            background: none;
            border: none;
            color: white;
            font-size: 30px;
            cursor: pointer;
        }

        .nav-container > div {
            display: flex;
            align-items: center; /* Ensure vertical center alignment within the div */
        }

        .nav-container img {
            vertical-align: middle; /* Helps remove any line-height or font-size related issues */
        }

        .apple-id {
            margin-right: 10px;
        }

        .github {
            margin-right: 10px;
        }

        @media (max-width: 768px) {
            .body-container {
                with: 100%;
                max-width: none;
            }

            .menu-toggle {
                display: block;
            }

            nav ul {
                display: none;
                flex-direction: column;
            }

            nav ul li {
                text-align: center;
                width: 100%;
            }

            nav ul li ul {
                position: static;
            }

            nav ul li:hover ul, nav ul li ul:hover {
                display: block;
            }
        }

        .github_corner {
            position: fixed;
            bottom: 0;
            left: 0;
            border: 0;
        }

    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/rust.min.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
    <script>hljs.highlightAll();</script>
',
-- This is the body of the HTML page
'
        <div class="github_corner">
            <a href="https://www.github.com/uberFoo" target="_blank">
                <svg xmlns="http://www.w3.org/2000/svg" width="80" height="80" viewBox="0 0 250 250" fill="#151513" style="transform: scaleY(-1)">
                    <path fill="#151513" d="M250 0L135 115h-15l-12 27L0 250V0z"/>
                    <path fill="#ddd" class="octo-arm" d="M122 109c15-9 9-19 9-19-3-7-2-11-2-11 1-7-3-2-3-2-4 5-2 11-2 11 3 10-5 15-9 16" style="-webkit-transform-origin: 120px 144px; transform-origin: 120px 144px"/>
                    <path fill="#ddd" class="octo-body" d="M135 115s-4 2-5 0l-14-14c-3-2-6-3-8-3 8-11 15-24-2-41-5-5-10-7-16-7-1-2-3-7-12-11 0 0-5 3-7 16-4 2-8 5-12 9s-7 8-9 12c-14 4-17 9-17 9 4 8 9 11 11 11 0 6 2 11 7 16 16 16 30 10 41 2 0 3 1 7 5 11l12 11c1 2-1 6-1 6z"/>
                </svg>
            </a>
        </div>
         <div class="nav-container">
            <button class="menu-toggle" id="menu-toggle">☰</button>
            <nav>
                <ul id="menu">
                    <li><a href="/">Home</a></li>
                    <li><a href="/categories">Categories</a>
                        <ul>
                            <li><a href="/category/rust">Rust</a></li>
                            <li><a href="/category/dwarf">dwarf</a></li>
                            <!-- More categories -->
                        </ul>
                    </li>
                    <li><a href="/about">About</a></li>
                </ul>
            </nav>
<div>
    <img src="/appleid_button@1x.png" class="apple-id" title="Sign in with Apple ID">
    <a href="https://github.com/login/oauth/authorize?client_id=fa5175ee3bcf21bf2b11&redirect_uri=https://uberfoo.com/auth/github&scope=user&state=XYZZY">
        <img src="/github-mark-white.png" width="20" class="github" title="Sign in with GitHub">
    </a>
</div>
        </div>

        <div class="body-container">
            MARKDOWN
            <footer style="text-align: right; padding: 20px;">
                <a href="mailto:uberfoo@me.com">✉️</a>
                <a href="https://twitter.com/share?ref_src=twsrc%5Etfw" class="twitter-share-button" data-show-count="false">Tweet</a><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
                <a href="https://twitter.com/uberFoo?ref_src=twsrc%5Etfw" class="twitter-follow-button" data-show-count="false">Follow @uberFoo</a><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
                <a href="https://www.github.com/uberFoo" target="_blank">
                    <img src="/github-mark-white.png" width="25">
                </a>
            </footer>
        </div>
    <script>
document.addEventListener("DOMContentLoaded", function () {
    // Toggle main menu with the hamburger icon
    var menuToggle = document.getElementById("menu-toggle");
    menuToggle.addEventListener("click", function () {
        var menu = document.getElementById("menu");
        menu.style.display = menu.style.display === "block" ? "none" : "block";
    });
});
    </script>
')